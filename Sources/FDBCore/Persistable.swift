import Foundation
import FDBIndexing

/// Persistable protocol - Storage-independent persistable model interface
///
/// This protocol defines the metadata and serialization interface for persistable data models.
/// It is storage-independent and can be used across all data model layers:
/// - RecordLayer (RDB-like): Structured records with primary keys
/// - DocumentLayer (Document store): Flexible documents with auto-generated IDs
/// - VectorLayer (Vector search): Vector embeddings with similarity search
/// - GraphLayer (Graph database): Nodes and edges with relationships
///
/// **Platform Support**:
/// - Client (iOS/macOS): Model definitions, metadata, Codable serialization
/// - Server (macOS/Linux): Full persistence with FDBRuntime
///
/// **Implementation**: Generated by @Persistable macro
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     #PrimaryKey<User>([\.userID])
///     #Index<User>([\.email])
///
///     var userID: Int64
///     var email: String
///     var name: String
/// }
/// ```
///
/// **Generated Properties**:
/// - `persistableType`: Type identifier (e.g., "User")
/// - `allFields`: All field names
/// - `indexDescriptors`: Index metadata
/// - `primaryKeyFields`: Primary key fields (if #PrimaryKey declared)
///
/// **Layer-Specific Behavior**:
/// - RecordLayer: `#PrimaryKey` required for relational model
/// - DocumentLayer: `#PrimaryKey` optional, auto-generates ObjectID
/// - VectorLayer: Typically uses `#Index<T>([\.embedding], type: VectorIndexKind(...))`
/// - GraphLayer: Nodes and edges have separate `#PrimaryKey` declarations
public protocol Persistable: Sendable, Codable {
    // MARK: - Metadata (Storage-independent)

    /// Type identifier for this persistable type
    ///
    /// This is the canonical name used across all layers to identify the type.
    ///
    /// **Examples**:
    /// - RecordLayer: "User", "Product", "Order"
    /// - DocumentLayer: "Article", "Comment"
    /// - VectorLayer: "Embedding", "Document"
    /// - GraphLayer: "Person", "Relationship"
    static var persistableType: String { get }

    /// All field names in the persistable type
    ///
    /// Includes all stored properties, in declaration order.
    ///
    /// **Example**: `["userID", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// Index descriptors for this persistable type
    ///
    /// Generated from `#Index<T>` macro declarations.
    ///
    /// **Example**:
    /// ```swift
    /// #Index<User>([\.email], type: ScalarIndexKind(), unique: true)
    /// #Index<Product>([\.embedding], type: VectorIndexKind(dimensions: 384))
    /// ```
    static var indexDescriptors: [IndexDescriptor] { get }

    /// Get field number for a field name (for Protobuf serialization)
    ///
    /// Used by serialization layers that require stable field numbering.
    ///
    /// - Parameter fieldName: The field name
    /// - Returns: Field number, or nil if field doesn't exist or numbering is not defined
    static func fieldNumber(for fieldName: String) -> Int?

    /// Get enum metadata for a field (if the field is an enum)
    ///
    /// Provides enum case information for validation and serialization.
    ///
    /// - Parameter fieldName: The field name
    /// - Returns: EnumMetadata if field is an enum, nil otherwise
    static func enumMetadata(for fieldName: String) -> EnumMetadata?
}

// MARK: - Default Implementations

public extension Persistable {
    /// Default implementation returns empty array (no indexes)
    static var indexDescriptors: [IndexDescriptor] { [] }

    /// Default implementation returns nil (no field numbers)
    static func fieldNumber(for fieldName: String) -> Int? { nil }

    /// Default implementation returns nil (no enum metadata)
    static func enumMetadata(for fieldName: String) -> EnumMetadata? { nil }
}
