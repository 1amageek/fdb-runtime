// IndexDescriptor.swift
// FDBIndexing - Index descriptor (metadata)
//
// Provides declarative index definition.
// Used by macro generation, schema definition, and execution layer interpretation.

import Foundation

/// Index descriptor (metadata)
///
/// **Purpose**: Declarative index definition
/// - Generated by macros (@Recordable)
/// - Used in schema definitions (Schema)
/// - Interpreted by execution layer (IndexManager)
///
/// **Design principles**:
/// - Pure metadata (no execution logic)
/// - Codable support (persistence & serialization)
/// - Type safety (kind management via IndexKind)
///
/// **Example**:
/// ```swift
/// // Single field index
/// let emailIndex = IndexDescriptor(
///     name: "User_email",
///     keyPaths: ["email"],
///     kind: try! IndexKind(ScalarIndexKind()),
///     commonOptions: .init(unique: true)
/// )
///
/// // Composite field index
/// let compositeIndex = IndexDescriptor(
///     name: "Product_category_price",
///     keyPaths: ["category", "price"],
///     kind: try! IndexKind(ScalarIndexKind()),
///     commonOptions: .init()
/// )
///
/// // Vector index
/// let vectorIndex = IndexDescriptor(
///     name: "Product_embedding_hnsw",
///     keyPaths: ["embedding"],
///     kind: try! IndexKind(
///         VectorIndexKind(dimensions: 384, metric: .cosine)
///     ),
///     commonOptions: .init()
/// )
/// ```
public struct IndexDescriptor: Sendable, Codable, Hashable {
    /// Index name (unique identifier)
    ///
    /// **Naming convention**: "{RecordType}_{field1}_{field2}_..."
    ///
    /// **Examples**:
    /// - "User_email"
    /// - "Product_category_price"
    /// - "Document_embedding_hnsw"
    ///
    /// **Note**: This name is actually used in FDB key space.
    /// Changing it breaks compatibility with existing data.
    public let name: String

    /// Indexed field names (KeyPath string representations)
    ///
    /// **Reason**: KeyPath<T, V> cannot be stored in arrays with different type parameters
    ///
    /// **Examples**:
    /// - ["email"]
    /// - ["category", "price"]
    /// - ["embedding"]
    ///
    /// **Note**: Converted to actual KeyPaths in execution layer (FDBRecordLayer).
    /// These strings contain only field names, no type information.
    public let keyPaths: [String]

    /// Index kind (type-erased wrapper)
    ///
    /// **Kind examples**:
    /// - Scalar: Standard B-tree index
    /// - Vector: HNSW similarity search
    /// - Spatial: Geographic coordinate search
    /// - Count/Sum/Min/Max: Aggregation indexes
    ///
    /// **Example**:
    /// ```swift
    /// // Built-in kind
    /// let kind = try IndexKind(ScalarIndexKind())
    ///
    /// // Extended kind (with configuration)
    /// let kind = try IndexKind(
    ///     VectorIndexKind(dimensions: 768, metric: .cosine)
    /// )
    /// ```
    public let kind: IndexKind

    /// Common options
    ///
    /// **Includes**:
    /// - unique: Uniqueness constraint
    /// - sparse: Exclude null values
    /// - metadata: User-defined metadata
    ///
    /// **Example**:
    /// ```swift
    /// // With uniqueness constraint
    /// let options = CommonIndexOptions(unique: true)
    ///
    /// // Sparse index
    /// let options = CommonIndexOptions(sparse: true)
    ///
    /// // Custom metadata
    /// let options = CommonIndexOptions(
    ///     metadata: ["category": "user_index", "version": "1.0"]
    /// )
    /// ```
    public let commonOptions: CommonIndexOptions

    /// Standard initializer
    ///
    /// **Example**:
    /// ```swift
    /// let descriptor = IndexDescriptor(
    ///     name: "User_email",
    ///     keyPaths: ["email"],
    ///     kind: try! IndexKind(ScalarIndexKind()),
    ///     commonOptions: .init(unique: true)
    /// )
    /// ```
    ///
    /// - Parameters:
    ///   - name: Index name (unique identifier)
    ///   - keyPaths: Array of indexed field names
    ///   - kind: Index kind (type-erased)
    ///   - commonOptions: Common options (default: empty)
    public init(
        name: String,
        keyPaths: [String],
        kind: IndexKind,
        commonOptions: CommonIndexOptions = .init()
    ) {
        self.name = name
        self.keyPaths = keyPaths
        self.kind = kind
        self.commonOptions = commonOptions
    }
}

// MARK: - Convenience Methods

extension IndexDescriptor {
    /// Whether index has uniqueness constraint
    ///
    /// **Example**:
    /// ```swift
    /// if descriptor.isUnique {
    ///     print("This is a unique index")
    /// }
    /// ```
    public var isUnique: Bool {
        commonOptions.unique
    }

    /// Whether index is sparse
    ///
    /// **Example**:
    /// ```swift
    /// if descriptor.isSparse {
    ///     print("This is a sparse index (null values excluded)")
    /// }
    /// ```
    public var isSparse: Bool {
        commonOptions.sparse
    }

    /// Index kind identifier
    ///
    /// **Example**:
    /// ```swift
    /// switch descriptor.kindIdentifier {
    /// case "scalar":
    ///     print("Scalar index")
    /// case "vector":
    ///     print("Vector index")
    /// default:
    ///     print("Unknown index kind: \(descriptor.kindIdentifier)")
    /// }
    /// ```
    public var kindIdentifier: String {
        kind.identifier
    }
}

// MARK: - Description

extension IndexDescriptor: CustomStringConvertible {
    public var description: String {
        var parts = [
            "IndexDescriptor(name: \(name)",
            "kind: \(kind.identifier)",
            "keyPaths: [\(keyPaths.joined(separator: ", "))]"
        ]

        if isUnique {
            parts.append("unique: true")
        }

        if isSparse {
            parts.append("sparse: true")
        }

        if !commonOptions.metadata.isEmpty {
            parts.append("metadata: \(commonOptions.metadata)")
        }

        return parts.joined(separator: ", ") + ")"
    }
}
