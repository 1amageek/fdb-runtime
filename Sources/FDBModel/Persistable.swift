/// Persistable protocol - Storage-independent persistable model interface
///
/// This protocol defines the metadata and serialization interface for persistable data models.
/// It is storage-independent and can be used across all data model layers:
/// - RecordLayer (RDB-like): Structured records
/// - DocumentLayer (Document store): Flexible documents
/// - VectorLayer (Vector search): Vector embeddings with similarity search
/// - GraphLayer (Graph database): Nodes and edges with relationships
///
/// **Platform Support**:
/// - Client (iOS/macOS): Model definitions, metadata, Codable serialization
/// - Server (macOS/Linux): Full persistence with FDBRuntime
///
/// **Implementation**: Generated by @Persistable macro
///
/// **Usage**:
/// ```swift
/// @Persistable
/// struct User {
///     var id: String = ULID().ulidString  // Optional: auto-generated if omitted
///
///     #Directory<User>("users")
///     #Index<User>([\.email], unique: true)
///
///     var email: String
///     var name: String
/// }
/// ```
///
/// **Generated Properties**:
/// - `id`: Unique identifier (auto-generated ULID if not defined)
/// - `persistableType`: Type identifier (e.g., "User")
/// - `allFields`: All field names
/// - `indexDescriptors`: Index metadata
///
/// **ID Behavior**:
/// - If user defines `id` field: uses that type and default value
/// - If user omits `id` field: macro adds `var id: String = ULID().ulidString`
/// - `id` is NOT included in the generated initializer
@dynamicMemberLookup
public protocol Persistable: Sendable, Codable {
    // MARK: - ID

    /// The type of the unique identifier
    ///
    /// **IMPORTANT**: When used with FDBRuntime (server-side), the ID type MUST also
    /// conform to `TupleElement` for FDB key encoding. This cannot be enforced at
    /// compile time because FDBModel is platform-independent (iOS/macOS clients).
    ///
    /// **Supported ID types** (conform to TupleElement):
    /// - `String` (recommended: ULID for sortable unique IDs)
    /// - `Int64`, `Int32`, `Int16`, `Int8`, `Int`
    /// - `UInt64`, `UInt32`, `UInt16`, `UInt8`, `UInt`
    /// - `UUID`
    /// - `Double`, `Float`
    /// - `Bool`
    /// - `Data`, `[UInt8]`
    ///
    /// **Unsupported** (will cause runtime error in FDBRuntime):
    /// - Custom structs/classes (unless they conform to TupleElement)
    /// - Enums (unless raw value is a supported type)
    associatedtype ID: Sendable & Hashable & Codable

    /// Unique identifier for this instance
    ///
    /// - Auto-generated: `var id: String = ULID().ulidString`
    /// - User-defined: Any type conforming to TupleElement
    ///
    /// **Important**: `id` is not included in the generated initializer.
    /// It is always auto-initialized with its default value.
    var id: ID { get }

    // MARK: - Metadata (Storage-independent)

    /// Type identifier for this persistable type
    ///
    /// This is the canonical name used across all layers to identify the type.
    /// Can be customized via `@Persistable(type: "CustomName")`.
    ///
    /// **Examples**:
    /// - Default: struct name (e.g., "User", "Product")
    /// - Custom: `@Persistable(type: "User")` on a `Member` struct
    static var persistableType: String { get }

    /// All field names in the persistable type
    ///
    /// Includes all stored properties (including `id`), in declaration order.
    ///
    /// **Example**: `["id", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// Index descriptors for this persistable type
    ///
    /// Generated from `#Index<T>` macro declarations.
    ///
    /// **Example**:
    /// ```swift
    /// #Index<User>([\.email], type: ScalarIndexKind(), unique: true)
    /// ```
    static var indexDescriptors: [IndexDescriptor] { get }

    /// Get field number for a field name (for Protobuf serialization)
    ///
    /// Used by serialization layers that require stable field numbering.
    ///
    /// - Parameter fieldName: The field name
    /// - Returns: Field number, or nil if field doesn't exist or numbering is not defined
    static func fieldNumber(for fieldName: String) -> Int?

    /// Get enum metadata for a field (if the field is an enum)
    ///
    /// Provides enum case information for validation and serialization.
    ///
    /// - Parameter fieldName: The field name
    /// - Returns: EnumMetadata if field is an enum, nil otherwise
    static func enumMetadata(for fieldName: String) -> EnumMetadata?

    // MARK: - Dynamic Field Access

    /// Access field values dynamically by name
    ///
    /// Enables runtime field access using string-based field names.
    /// This is used by DataAccess for KeyExpression evaluation and index building.
    ///
    /// **Implementation**: Generated by @Persistable macro
    ///
    /// **Example**:
    /// ```swift
    /// @Persistable
    /// struct User {
    ///     var email: String
    /// }
    ///
    /// let user = User(email: "user@example.com")
    /// let email = user[dynamicMember: "email"]  // Optional<any Sendable>
    /// ```
    ///
    /// - Parameter member: Field name to access
    /// - Returns: Field value as Sendable, or nil if field doesn't exist
    subscript(dynamicMember member: String) -> (any Sendable)? { get }

    // MARK: - KeyPath Support

    /// Convert a KeyPath to its field name string representation
    ///
    /// **Implementation**: Generated by @Persistable macro
    ///
    /// **Example**:
    /// ```swift
    /// @Persistable
    /// struct User {
    ///     var email: String
    ///     var address: Address
    /// }
    ///
    /// User.fieldName(for: \.email)           // "email"
    /// User.fieldName(for: \.address.city)    // "address.city"
    /// ```
    ///
    /// - Parameter keyPath: KeyPath to convert
    /// - Returns: Dot-notation field name string
    static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String

    /// Convert a PartialKeyPath to its field name string representation
    ///
    /// - Parameter keyPath: PartialKeyPath to convert
    /// - Returns: Dot-notation field name string
    static func fieldName(for keyPath: PartialKeyPath<Self>) -> String

    /// Convert an AnyKeyPath to its field name string representation
    ///
    /// Used when the concrete type is erased. Falls back to KeyPath description
    /// if the keyPath doesn't belong to this type.
    ///
    /// - Parameter keyPath: AnyKeyPath to convert
    /// - Returns: Dot-notation field name string
    static func fieldName(for keyPath: AnyKeyPath) -> String
}

// MARK: - Default Implementations

public extension Persistable {
    /// Default implementation returns empty array (no indexes)
    static var indexDescriptors: [IndexDescriptor] { [] }

    /// Default implementation returns nil (no field numbers)
    static func fieldNumber(for fieldName: String) -> Int? { nil }

    /// Default implementation returns nil (no enum metadata)
    static func enumMetadata(for fieldName: String) -> EnumMetadata? { nil }

    /// Default implementation for fieldName - returns KeyPath description
    ///
    /// **Note**: @Persistable macro generates a proper implementation.
    /// This default is for types that don't use the macro.
    static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String {
        "\(keyPath)"
    }

    /// Default implementation for fieldName (PartialKeyPath version)
    static func fieldName(for keyPath: PartialKeyPath<Self>) -> String {
        "\(keyPath)"
    }

    /// Default implementation for fieldName (AnyKeyPath version)
    ///
    /// Attempts to cast to PartialKeyPath<Self> and delegate, otherwise uses description.
    static func fieldName(for keyPath: AnyKeyPath) -> String {
        if let partialKeyPath = keyPath as? PartialKeyPath<Self> {
            return fieldName(for: partialKeyPath)
        }
        return "\(keyPath)"
    }

    /// Register this type for index building during migrations (optional)
    ///
    /// **Default Implementation**: Does nothing.
    ///
    /// **Note**: This method is provided for backward compatibility and advanced
    /// use cases. The primary index building flow uses `_EntityIndexBuildable`
    /// protocol, which automatically works for all `Persistable & Codable` types.
    ///
    /// **FDBIndexing Override**: For `Persistable & Codable` types,
    /// FDBIndexing provides a specialized implementation that registers
    /// the type with `IndexBuilderRegistry` for optional manual registry usage.
    static func registerForIndexBuilding() {
        // Default: do nothing
        // FDBIndexing provides specialized implementation for Codable types
    }
}
