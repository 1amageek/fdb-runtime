// IndexDescriptor.swift
// FDBModel - Index descriptor (metadata)
//
// Provides declarative index definition using Swift KeyPaths.
// Used by macro generation, schema definition, and execution layer interpretation.

/// Index descriptor (metadata)
///
/// **Purpose**: Declarative index definition using KeyPaths
/// - Generated by macros (@Persistable)
/// - Used in schema definitions (Schema)
/// - Interpreted by execution layer (IndexMaintainer)
///
/// **Design principles**:
/// - Pure metadata (no execution logic)
/// - Type-safe KeyPath storage
/// - Refactoring-friendly (IDE renames propagate)
///
/// **Example**:
/// ```swift
/// @Persistable
/// struct User {
///     #Index<User>([\.email], unique: true)
///     #Index<User>([\.address.city])
///     #Index<User>([\.period.lowerBound])
///
///     var email: String
///     var address: Address
///     var period: Range<Date>
/// }
///
/// // Generated IndexDescriptors use KeyPaths directly:
/// // - [\User.email]
/// // - [\User.address.city]
/// // - [\User.period.lowerBound]
/// ```
public struct IndexDescriptor: @unchecked Sendable {
    /// Index name (unique identifier)
    ///
    /// **Naming convention**: "{RecordType}_{field1}_{field2}_..."
    ///
    /// **Examples**:
    /// - "User_email"
    /// - "User_address_city"
    /// - "Product_category_price"
    ///
    /// **Note**: This name is used in FDB key space.
    /// Changing it breaks compatibility with existing data.
    public let name: String

    /// Indexed field KeyPaths
    ///
    /// **Benefits of KeyPath storage**:
    /// - Type-safe field access
    /// - Refactoring-friendly (IDE renames propagate)
    /// - Direct access without string parsing
    /// - Supports nested fields (\.address.city)
    /// - Supports Range bounds (\.period.lowerBound)
    ///
    /// **Examples**:
    /// - [\User.email]
    /// - [\User.address.city]
    /// - [\Product.category, \Product.price]
    public let keyPaths: [AnyKeyPath]

    /// Index kind
    ///
    /// **Kind examples**:
    /// - Scalar: Standard B-tree index
    /// - Vector: HNSW similarity search
    /// - Count/Sum/Min/Max: Aggregation indexes
    ///
    /// **Example**:
    /// ```swift
    /// let kind: any IndexKind = ScalarIndexKind()
    /// ```
    public let kind: any IndexKind

    /// Common options
    ///
    /// **Includes**:
    /// - unique: Uniqueness constraint
    /// - sparse: Exclude null values
    /// - metadata: User-defined metadata
    public let commonOptions: CommonIndexOptions

    /// Standard initializer with typed KeyPaths
    ///
    /// **Example**:
    /// ```swift
    /// let descriptor = IndexDescriptor(
    ///     name: "User_email",
    ///     keyPaths: [\User.email],
    ///     kind: ScalarIndexKind(),
    ///     commonOptions: .init(unique: true)
    /// )
    /// ```
    ///
    /// - Parameters:
    ///   - name: Index name (unique identifier)
    ///   - keyPaths: Array of KeyPaths to indexed fields
    ///   - kind: Index kind metadata
    ///   - commonOptions: Common options (default: empty)
    public init<Root>(
        name: String,
        keyPaths: [PartialKeyPath<Root>],
        kind: any IndexKind,
        commonOptions: CommonIndexOptions = .init()
    ) {
        self.name = name
        self.keyPaths = keyPaths
        self.kind = kind
        self.commonOptions = commonOptions
    }

    /// Initializer with AnyKeyPath array (for internal use)
    public init(
        name: String,
        anyKeyPaths: [AnyKeyPath],
        kind: any IndexKind,
        commonOptions: CommonIndexOptions = .init()
    ) {
        self.name = name
        self.keyPaths = anyKeyPaths
        self.kind = kind
        self.commonOptions = commonOptions
    }
}

// MARK: - Convenience Methods

extension IndexDescriptor {
    /// Whether index has uniqueness constraint
    ///
    /// **Example**:
    /// ```swift
    /// if descriptor.isUnique {
    ///     print("This is a unique index")
    /// }
    /// ```
    public var isUnique: Bool {
        commonOptions.unique
    }

    /// Whether index is sparse
    ///
    /// **Example**:
    /// ```swift
    /// if descriptor.isSparse {
    ///     print("This is a sparse index (null values excluded)")
    /// }
    /// ```
    public var isSparse: Bool {
        commonOptions.sparse
    }

    /// Index kind identifier
    ///
    /// **Example**:
    /// ```swift
    /// switch descriptor.kindIdentifier {
    /// case "scalar":
    ///     print("Scalar index")
    /// case "vector":
    ///     print("Vector index")
    /// default:
    ///     print("Unknown index kind: \(descriptor.kindIdentifier)")
    /// }
    /// ```
    public var kindIdentifier: String {
        type(of: kind).identifier
    }
}

// MARK: - Description

extension IndexDescriptor: CustomStringConvertible {
    public var description: String {
        let keyPathsDesc = keyPaths.map { String(describing: $0) }.joined(separator: ", ")
        var parts = [
            "IndexDescriptor(name: \(name)",
            "kind: \(type(of: kind).identifier)",
            "keyPaths: [\(keyPathsDesc)]"
        ]

        if isUnique {
            parts.append("unique: true")
        }

        if isSparse {
            parts.append("sparse: true")
        }

        if !commonOptions.metadata.isEmpty {
            parts.append("metadata: \(commonOptions.metadata)")
        }

        return parts.joined(separator: ", ") + ")"
    }
}
